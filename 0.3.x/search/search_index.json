{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Polymer It's a set of libraries designed for creation of server side content, that work for player's without mods or (required) resource packs! You can create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones allowing for way better mod compatibility and way less weird edge-cases. It is also should be fully compatible with close to all other mods and in case of found issues they are patched as soon as possible. Updating from 0.2.x With Minecraft 1.19.3 being globally breaking update. I took this as a good time to make breaking changes to polymer itself. See this update guide for more informations! Modules Polymer Core eu.pb4:polymer-core It's a heart of Polymer. It allows you to create server side content. It also contains lots of extra mod compatibility for client mods, to make your mod better fit for any modpack. Getting Started Items Blocks Entities Other custom features (Optional) Client Side features Polymer Resource Pack eu.pb4:polymer-resource-pack Allows creating global (and mod specific) resource packs. It also patches PolyMc to make it's resource generation work with polymer. Getting Started Basics Polymer Networking eu.pb4:polymer-networking Polymer's Networking API. Uses its own custom synchronization code. Contains extra API, more specific that aren't available in fabric. Getting Started Basics Polymer Blocks eu.pb4:polymer-blocks Extension of Polymer Core and Resource Pack. Allows creation of textured blocks. Getting Started Basics Other useful tools/projects compatible with Polymer Server Translation API","title":"About Polymer"},{"location":"#about-polymer","text":"It's a set of libraries designed for creation of server side content, that work for player's without mods or (required) resource packs! You can create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones allowing for way better mod compatibility and way less weird edge-cases. It is also should be fully compatible with close to all other mods and in case of found issues they are patched as soon as possible.","title":"About Polymer"},{"location":"#updating-from-02x","text":"With Minecraft 1.19.3 being globally breaking update. I took this as a good time to make breaking changes to polymer itself. See this update guide for more informations!","title":"Updating from 0.2.x"},{"location":"#modules","text":"","title":"Modules"},{"location":"#polymer-core","text":"eu.pb4:polymer-core It's a heart of Polymer. It allows you to create server side content. It also contains lots of extra mod compatibility for client mods, to make your mod better fit for any modpack. Getting Started Items Blocks Entities Other custom features (Optional) Client Side features","title":"Polymer Core"},{"location":"#polymer-resource-pack","text":"eu.pb4:polymer-resource-pack Allows creating global (and mod specific) resource packs. It also patches PolyMc to make it's resource generation work with polymer. Getting Started Basics","title":"Polymer Resource Pack"},{"location":"#polymer-networking","text":"eu.pb4:polymer-networking Polymer's Networking API. Uses its own custom synchronization code. Contains extra API, more specific that aren't available in fabric. Getting Started Basics","title":"Polymer Networking"},{"location":"#polymer-blocks","text":"eu.pb4:polymer-blocks Extension of Polymer Core and Resource Pack. Allows creation of textured blocks. Getting Started Basics","title":"Polymer Blocks"},{"location":"#other-useful-toolsprojects-compatible-with-polymer","text":"Server Translation API","title":"Other useful tools/projects compatible with Polymer"},{"location":"other/server-translation-api/","text":"Server Translation API It's a library for handling translations server side. It supports per player language, by using one provided by client on join/language change. Adding as dependency: Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"fr.catcore:server-translations-api:[TAG]\") } For [TAG] /translations api version I recommend you checking this maven . Usage To use i, you just need to use vanilla TranslationText with key specified by you in your code. Then you just need to create data/modid/lang folder in your mod resources. Then you can create there en_us.json for default translation and other language files for other. Example valid language file looks like this: { \"block.honeytech.pipe\": \"Pipe\", \"block.honeytech.item_extractor\": \"Item Extractor\", \"block.honeytech.trashcan\": \"Trash Can\", \"block.honeytech.cable\": \"Cable\", \"item.honeytech.diamond_dust\": \"Diamond Dust\", \"item.honeytech.raw_aluminium\": \"Raw Aluminium Ore\", \"item.honeytech.aluminium_ingot\": \"Aluminium Ingot\", \"item.honeytech.copper_wire\": \"Copper Wire\", \"item.honeytech.motor\": \"Motor\", \"gui.honeytech.show_recipes\": \"Show Recipes\" }","title":"Server Translation API"},{"location":"other/server-translation-api/#server-translation-api","text":"It's a library for handling translations server side. It supports per player language, by using one provided by client on join/language change.","title":"Server Translation API"},{"location":"other/server-translation-api/#adding-as-dependency","text":"Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"fr.catcore:server-translations-api:[TAG]\") } For [TAG] /translations api version I recommend you checking this maven .","title":"Adding as dependency:"},{"location":"other/server-translation-api/#usage","text":"To use i, you just need to use vanilla TranslationText with key specified by you in your code. Then you just need to create data/modid/lang folder in your mod resources. Then you can create there en_us.json for default translation and other language files for other. Example valid language file looks like this: { \"block.honeytech.pipe\": \"Pipe\", \"block.honeytech.item_extractor\": \"Item Extractor\", \"block.honeytech.trashcan\": \"Trash Can\", \"block.honeytech.cable\": \"Cable\", \"item.honeytech.diamond_dust\": \"Diamond Dust\", \"item.honeytech.raw_aluminium\": \"Raw Aluminium Ore\", \"item.honeytech.aluminium_ingot\": \"Aluminium Ingot\", \"item.honeytech.copper_wire\": \"Copper Wire\", \"item.honeytech.motor\": \"Motor\", \"gui.honeytech.show_recipes\": \"Show Recipes\" }","title":"Usage"},{"location":"other/updating-0.2.x-to-0.3/","text":"Updating from Polymer 0.2.x to 0.3.x polymer library got split up The polymer library was broken into multiple ones, most notably: polymer-common - Common code shared between modules polymer-core - All core functionality of polymer. Contains everything required for making server side content + client mod compatibility polymer-resource-pack - Resource pack support polymer-networking - Polymer's previous networking api All modules (excluding polymer-reg-sync-manipulator ) also depend (and include) common module. Core additionally depends on polymer-networking , which is used for client sync. Autohost module now depends only on polymer-networking and polymer-resource-pack . Packages/Class name changes With the split up, many classes changed their packages. polymer-blocks-ext got renamed to polymer-blocks From polymer ( polymer-core , polymer-resource-pack , polymer-networking ) eu.pb4.polymer.api.networking -> eu.pb4.polymer.networking.api (in polymer-networking ): PolymerPacketUtils is now PolymerServerNetworking Networking parts of eu.pb4.polymer.api.client.PolymerClientUtils are moved to eu.pb4.polymer.api.networking.PolymerClientNetworking eu.pb4.polymer.api.resourcepack -> eu.pb4.polymer.resourcepack.api (in polymer-resource-pack ): PolymerRPUtils -> PolymerResourcePackUtils PolymerRPBuilder -> ResourcePackBuilder Rest of eu.pb4.polymer.api -> eu.pb4.polymer.core.api (in polymer-core ): [...].networking.PolymerSyncUtils -> [...].utils.PolymerSyncUtils PolymerUtils#getPlayer -> PolymerUtils#getPlayerContext Interfaces in client that were used on both sides were moved to utils [...].client.registry -> [...].client PolymerEntity#modifyTrackedData -> PolymerEntity#modifyRawTrackedData eu.pb4.polymer.ext.blocks -> eu.pb4.polymer.blocks (in polymer-blocks ) Additionally, a bunch of method parameters changed to make them more consistent (making ServerPlayerEntity last argument). Many old duplicate context-less methods got removed if they were only accessed by one with player context. Submodule versioning change. All modules now use same version. This mostly makes it easier to update everything, but also makes some version bumps that don't change anything in some.","title":"Updating from Polymer 0.2.x to 0.3.x"},{"location":"other/updating-0.2.x-to-0.3/#updating-from-polymer-02x-to-03x","text":"","title":"Updating from Polymer 0.2.x to 0.3.x"},{"location":"other/updating-0.2.x-to-0.3/#polymer-library-got-split-up","text":"The polymer library was broken into multiple ones, most notably: polymer-common - Common code shared between modules polymer-core - All core functionality of polymer. Contains everything required for making server side content + client mod compatibility polymer-resource-pack - Resource pack support polymer-networking - Polymer's previous networking api All modules (excluding polymer-reg-sync-manipulator ) also depend (and include) common module. Core additionally depends on polymer-networking , which is used for client sync. Autohost module now depends only on polymer-networking and polymer-resource-pack .","title":"polymer library got split up"},{"location":"other/updating-0.2.x-to-0.3/#packagesclass-name-changes","text":"With the split up, many classes changed their packages. polymer-blocks-ext got renamed to polymer-blocks From polymer ( polymer-core , polymer-resource-pack , polymer-networking ) eu.pb4.polymer.api.networking -> eu.pb4.polymer.networking.api (in polymer-networking ): PolymerPacketUtils is now PolymerServerNetworking Networking parts of eu.pb4.polymer.api.client.PolymerClientUtils are moved to eu.pb4.polymer.api.networking.PolymerClientNetworking eu.pb4.polymer.api.resourcepack -> eu.pb4.polymer.resourcepack.api (in polymer-resource-pack ): PolymerRPUtils -> PolymerResourcePackUtils PolymerRPBuilder -> ResourcePackBuilder Rest of eu.pb4.polymer.api -> eu.pb4.polymer.core.api (in polymer-core ): [...].networking.PolymerSyncUtils -> [...].utils.PolymerSyncUtils PolymerUtils#getPlayer -> PolymerUtils#getPlayerContext Interfaces in client that were used on both sides were moved to utils [...].client.registry -> [...].client PolymerEntity#modifyTrackedData -> PolymerEntity#modifyRawTrackedData eu.pb4.polymer.ext.blocks -> eu.pb4.polymer.blocks (in polymer-blocks ) Additionally, a bunch of method parameters changed to make them more consistent (making ServerPlayerEntity last argument). Many old duplicate context-less methods got removed if they were only accessed by one with player context.","title":"Packages/Class name changes"},{"location":"other/updating-0.2.x-to-0.3/#submodule-versioning-change","text":"All modules now use same version. This mostly makes it easier to update everything, but also makes some version bumps that don't change anything in some.","title":"Submodule versioning change."},{"location":"polymer-blocks/basics/","text":"Basics Creating a block. Creating a block is mostly the same as with regular polymer ones. Only difference is implementation of PolymerTexturedBlock interface, which acts as a marker. Supported block shapes/types Polymer Blocks supports few types of models/shapes. However, possible amount of blocks is limited, because we can't really add fully custom blocks on client yet. Every block type has its own functionality and behaviour: FULL_BLOCK - Noteblocks, have full collision and don't allow transparency, (limit: 799) TRANSPARENT_BLOCK - Mostly leaves, allow \"cutout\" textures, (limit: 104) FARMLAND_BLOCK - Farmland blocks, (limit: 5!) VINES_BLOCK - All centered vine blocks, Cave Vines, Twisted Vines and Weeping Vines, (limit: 100) PLANT_BLOCK - Small plant blocks, sugarcane and saplings, (limit: 21) KELP_BLOCK - Just kelp, (limit: 25) CACTUS_BLOCK - Just cactus, (limit: 15!) They all are accessible from BlockModelType enum. Defining a global model First thing you do, is creating a model definition. You should do that by calling one of PolymerBlockModel.of(...) methods. It takes the same argument as vanilla definition in assets/(namespace)/blockstate/(block).json file. Then you need to request a model. It's as simple as calling PolymerBlockResourceUtils.requestBlock(BlockModelType type, PolymerBlockModel... model) with one or more models. It returns a blockstate, that you need to use in your PolymerTexturedBlock as result of getPolymerBlockState(...) . If it runs out of free BlockStates to use, it will return null instead. You can also check amount of free blocks with PolymerBlockResourceUtils.getBlocksLeft(BlockModelType type) . If you've done everything correctly, it should now display as your model. Otherwise, you either skipped some step or didn't apply server resource pack. Remember that you still need to register your assets with PolymerRPUtils.addAssetSource(String modId) method. Just keep in mind Some block model types have very small amount of free BlockStates. For that reason, while making public registering blocks globally, please allow for disabling of them and handle running out of them for best compatibility and mod support!","title":"Basics"},{"location":"polymer-blocks/basics/#basics","text":"","title":"Basics"},{"location":"polymer-blocks/basics/#creating-a-block","text":"Creating a block is mostly the same as with regular polymer ones. Only difference is implementation of PolymerTexturedBlock interface, which acts as a marker.","title":"Creating a block."},{"location":"polymer-blocks/basics/#supported-block-shapestypes","text":"Polymer Blocks supports few types of models/shapes. However, possible amount of blocks is limited, because we can't really add fully custom blocks on client yet. Every block type has its own functionality and behaviour: FULL_BLOCK - Noteblocks, have full collision and don't allow transparency, (limit: 799) TRANSPARENT_BLOCK - Mostly leaves, allow \"cutout\" textures, (limit: 104) FARMLAND_BLOCK - Farmland blocks, (limit: 5!) VINES_BLOCK - All centered vine blocks, Cave Vines, Twisted Vines and Weeping Vines, (limit: 100) PLANT_BLOCK - Small plant blocks, sugarcane and saplings, (limit: 21) KELP_BLOCK - Just kelp, (limit: 25) CACTUS_BLOCK - Just cactus, (limit: 15!) They all are accessible from BlockModelType enum.","title":"Supported block shapes/types"},{"location":"polymer-blocks/basics/#defining-a-global-model","text":"First thing you do, is creating a model definition. You should do that by calling one of PolymerBlockModel.of(...) methods. It takes the same argument as vanilla definition in assets/(namespace)/blockstate/(block).json file. Then you need to request a model. It's as simple as calling PolymerBlockResourceUtils.requestBlock(BlockModelType type, PolymerBlockModel... model) with one or more models. It returns a blockstate, that you need to use in your PolymerTexturedBlock as result of getPolymerBlockState(...) . If it runs out of free BlockStates to use, it will return null instead. You can also check amount of free blocks with PolymerBlockResourceUtils.getBlocksLeft(BlockModelType type) . If you've done everything correctly, it should now display as your model. Otherwise, you either skipped some step or didn't apply server resource pack. Remember that you still need to register your assets with PolymerRPUtils.addAssetSource(String modId) method.","title":"Defining a global model"},{"location":"polymer-blocks/basics/#just-keep-in-mind","text":"Some block model types have very small amount of free BlockStates. For that reason, while making public registering blocks globally, please allow for disabling of them and handle running out of them for best compatibility and mod support!","title":"Just keep in mind"},{"location":"polymer-blocks/getting-started/","text":"Getting Started This is additional module/extension of Polymer, adding support for textured blocks. It requires server resource pack to be active work correctly. It requires Polymer Core and Polymer Resource Pack modules to work. Adding to dependencies repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-core:[TAG]\") modImplementation include(\"eu.pb4:polymer-blocks:[TAG]\") modImplementation include(\"eu.pb4:polymer-resource-pack:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version:","title":"Getting Started"},{"location":"polymer-blocks/getting-started/#getting-started","text":"This is additional module/extension of Polymer, adding support for textured blocks. It requires server resource pack to be active work correctly. It requires Polymer Core and Polymer Resource Pack modules to work.","title":"Getting Started"},{"location":"polymer-blocks/getting-started/#adding-to-dependencies","text":"repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-core:[TAG]\") modImplementation include(\"eu.pb4:polymer-blocks:[TAG]\") modImplementation include(\"eu.pb4:polymer-resource-pack:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version:","title":"Adding to dependencies"},{"location":"polymer-core/blocks/","text":"Blocks Note These docs will only take care about polymer-related part of creation of blocks. You might want to see official Fabric Wiki for more in depth look into how to create blocks. You can skip some client side specific things, as it won't take effect server side (for example models and textures). Creation of blocks Creation of blocks, similarly to items, is mostly the same as vanilla. Only real difference is that your blocks need to implement Polymer's PolymerBlock interface. It exposes few defaulted methods for manipulation of client side visuals. Default implementation For most basic uses, there are default implementation of PolymerBlock : PolymerHeadBlock - It's an interface (!), that has basic implementation of player head based blocks, you still need to apply it to your Block class, SimplePolymerBlock - Same as vanilla Block . Selecting base polymer block type. To change base block, you need to override Block getPolymerBlock(BlockState) method. You can also override Block getPolymerBlock(ServerPlayerEntity, BlockState) to replace blocks per player, however keep in mind they should ideally have same collisions. Both of these methods can't return null. They can also point to other PolymerBlock instances, but keep in mind to make validation if it's configurable by user! Example use: Making block look like a diamond @Override public Block getPolymerBlock(BlockState state) { return Blocks.BARRIER; } public Block getPolymerBlock(ServerPlayerEntity player, BlockState state) { return Something.isRedTeam(player) ? Blocks.RED_WOOL : Blocks.BLUE_WOOL; } Changing client-side and collision BlockStates If you want to change what BlockState will be used for server side collision and client side you need to override BlockState getPolymerBlockState(BlockState state) method. You can also override BlockState getPolymerBlockState(BlockState state, ServerPlayerEntity player) for player context, similar to getPolymerBlock . You can return other BlockState of PolymerBlock, but keep in mind you can only nest them up to 32! Example use: Changing BlockState to furnace with the same facing, but inverted \"lit\" BlockState property @Override public BlockState getPolymerBlockState(BlockState state) { return Blocks.FURNACE.getDefaultState() .with(AbstractFurnaceBlock.FACING, state.get(AbstractFurnaceBlock.FACING)) .with(AbstractFurnaceBlock.LIT, !state.get(AbstractFurnaceBlock.LIT)); } Sending additional data (signs/heads or even custom) In case if you want to send additional (to more customize look on client for signs/heads or additional data for companion mod), you need to override onPolymerBlockSend(BlockState blockState, BlockPos.Mutable pos, ServerPlayerEntity player) . Technically you can do anything there, but ideally it should be only used for packets. Example use: Sending data required to render player head with skin @Override public void onPolymerBlockSend(BlockState blockState, BlockPos.Mutable pos, ServerPlayerEntity player) { player.networkHandler.sendPacket(this.getPolymerHeadPacket(blockState, pos.toImmutable())); } Using PolymerHeadBlock PolymerHeadBlock is an interface extending PolymerBlock with methods prepared for usage of player heads as a block. To modify texture, you just need to override String getPolymerSkinValue(BlockState state, BlockPos pos, ServerPlayerEntity entity) which should return texture value. To generate it you can use websites like https://mineskin.org/. Additionally, you can override BlockState getPolymerBlockState(BlockState state) to change rotation of Player Head Block. Example use: Setting skin value for PolymerHeadBlock @Override public String getPolymerSkinValue(BlockState state, BlockPos pos, ServerPlayerEntity entity) { return \"ewogICJ0aW1lc3RhbXAiIDogMTYxNzk3NjcxOTAzNSwKICAicHJvZmlsZUlkIiA6ICJlZDUzZGQ4MTRmOWQ0YTNjYjRlYjY1MWRjYmE3N2U2NiIsCiAgInByb2ZpbGVOYW1lIiA6ICI0MTQxNDE0MWgiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTczNTE0YTIzMjQ1ZjE1ZGJhZDVmYjRlNjIyMTYzMDIwODY0Y2NlNGMxNWQ1NmRlM2FkYjkwZmE1YTcxMzdmZCIKICAgIH0KICB9Cn0\"; } Textured, non-player-head blocks See Polymer Textured Blocks extension for more informations Using BlockEntities The only thing you need to do to remove BlockEntity from being sent to client is registering its BlockEntityType with PolymerBlockUtils.registerBlockEntity(BlockEntityType types) . Getting Polymer Blocks client representation If you want to get client-friendly representation of block, you need to call PolymerBlockUtils.getBlockStateSafely(PolymerBlock block, BlockState blockState) method. It should return block safe to use (or air in case of failure). Limitations While it's supported, please limit creation of PolymerBlock light sources. Because of how Minecraft handles light updates on server/client, these can be little laggy (as it needs to be sent updates every time light changes) and not perfect, as client is emulating light by itself. Similarly, client recalculates some BlockStates, which can cause some desyncs.","title":"Blocks"},{"location":"polymer-core/blocks/#blocks","text":"Note These docs will only take care about polymer-related part of creation of blocks. You might want to see official Fabric Wiki for more in depth look into how to create blocks. You can skip some client side specific things, as it won't take effect server side (for example models and textures).","title":"Blocks"},{"location":"polymer-core/blocks/#creation-of-blocks","text":"Creation of blocks, similarly to items, is mostly the same as vanilla. Only real difference is that your blocks need to implement Polymer's PolymerBlock interface. It exposes few defaulted methods for manipulation of client side visuals.","title":"Creation of blocks"},{"location":"polymer-core/blocks/#default-implementation","text":"For most basic uses, there are default implementation of PolymerBlock : PolymerHeadBlock - It's an interface (!), that has basic implementation of player head based blocks, you still need to apply it to your Block class, SimplePolymerBlock - Same as vanilla Block .","title":"Default implementation"},{"location":"polymer-core/blocks/#selecting-base-polymer-block-type","text":"To change base block, you need to override Block getPolymerBlock(BlockState) method. You can also override Block getPolymerBlock(ServerPlayerEntity, BlockState) to replace blocks per player, however keep in mind they should ideally have same collisions. Both of these methods can't return null. They can also point to other PolymerBlock instances, but keep in mind to make validation if it's configurable by user! Example use: Making block look like a diamond @Override public Block getPolymerBlock(BlockState state) { return Blocks.BARRIER; } public Block getPolymerBlock(ServerPlayerEntity player, BlockState state) { return Something.isRedTeam(player) ? Blocks.RED_WOOL : Blocks.BLUE_WOOL; }","title":"Selecting base polymer block type."},{"location":"polymer-core/blocks/#changing-client-side-and-collision-blockstates","text":"If you want to change what BlockState will be used for server side collision and client side you need to override BlockState getPolymerBlockState(BlockState state) method. You can also override BlockState getPolymerBlockState(BlockState state, ServerPlayerEntity player) for player context, similar to getPolymerBlock . You can return other BlockState of PolymerBlock, but keep in mind you can only nest them up to 32! Example use: Changing BlockState to furnace with the same facing, but inverted \"lit\" BlockState property @Override public BlockState getPolymerBlockState(BlockState state) { return Blocks.FURNACE.getDefaultState() .with(AbstractFurnaceBlock.FACING, state.get(AbstractFurnaceBlock.FACING)) .with(AbstractFurnaceBlock.LIT, !state.get(AbstractFurnaceBlock.LIT)); }","title":"Changing client-side and collision BlockStates"},{"location":"polymer-core/blocks/#sending-additional-data-signsheads-or-even-custom","text":"In case if you want to send additional (to more customize look on client for signs/heads or additional data for companion mod), you need to override onPolymerBlockSend(BlockState blockState, BlockPos.Mutable pos, ServerPlayerEntity player) . Technically you can do anything there, but ideally it should be only used for packets. Example use: Sending data required to render player head with skin @Override public void onPolymerBlockSend(BlockState blockState, BlockPos.Mutable pos, ServerPlayerEntity player) { player.networkHandler.sendPacket(this.getPolymerHeadPacket(blockState, pos.toImmutable())); }","title":"Sending additional data (signs/heads or even custom)"},{"location":"polymer-core/blocks/#using-polymerheadblock","text":"PolymerHeadBlock is an interface extending PolymerBlock with methods prepared for usage of player heads as a block. To modify texture, you just need to override String getPolymerSkinValue(BlockState state, BlockPos pos, ServerPlayerEntity entity) which should return texture value. To generate it you can use websites like https://mineskin.org/. Additionally, you can override BlockState getPolymerBlockState(BlockState state) to change rotation of Player Head Block. Example use: Setting skin value for PolymerHeadBlock @Override public String getPolymerSkinValue(BlockState state, BlockPos pos, ServerPlayerEntity entity) { return \"ewogICJ0aW1lc3RhbXAiIDogMTYxNzk3NjcxOTAzNSwKICAicHJvZmlsZUlkIiA6ICJlZDUzZGQ4MTRmOWQ0YTNjYjRlYjY1MWRjYmE3N2U2NiIsCiAgInByb2ZpbGVOYW1lIiA6ICI0MTQxNDE0MWgiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTczNTE0YTIzMjQ1ZjE1ZGJhZDVmYjRlNjIyMTYzMDIwODY0Y2NlNGMxNWQ1NmRlM2FkYjkwZmE1YTcxMzdmZCIKICAgIH0KICB9Cn0\"; }","title":"Using PolymerHeadBlock"},{"location":"polymer-core/blocks/#textured-non-player-head-blocks","text":"See Polymer Textured Blocks extension for more informations","title":"Textured, non-player-head blocks"},{"location":"polymer-core/blocks/#using-blockentities","text":"The only thing you need to do to remove BlockEntity from being sent to client is registering its BlockEntityType with PolymerBlockUtils.registerBlockEntity(BlockEntityType types) .","title":"Using BlockEntities"},{"location":"polymer-core/blocks/#getting-polymer-blocks-client-representation","text":"If you want to get client-friendly representation of block, you need to call PolymerBlockUtils.getBlockStateSafely(PolymerBlock block, BlockState blockState) method. It should return block safe to use (or air in case of failure).","title":"Getting Polymer Blocks client representation"},{"location":"polymer-core/blocks/#limitations","text":"While it's supported, please limit creation of PolymerBlock light sources. Because of how Minecraft handles light updates on server/client, these can be little laggy (as it needs to be sent updates every time light changes) and not perfect, as client is emulating light by itself. Similarly, client recalculates some BlockStates, which can cause some desyncs.","title":"Limitations"},{"location":"polymer-core/client-side/","text":"Client side features While Polymer by itself is mainly server side api, it includes some client side functionality for mods to use. It allows you for example to display vanilla friendly item for normal clients and custom models if it's present on server. Keeping modded item/block on compatible client. To keep client side model for loading, you need to implement PolymerKeepModel interface on your modded object. To enable it's decoding, just add PolymerClientDecoded interface for it. After that, you just need to return server side items/block in corresponding player-aware getPolymerX methods. To \"sync\" presence/version of your mod you can use Polymer's handshake feature. You can do that by registering packets for which you should check Polymer Networking documentation After that you can just validate if player supports it with this check it like this SomeObject getPolymerX(ServerPlayerEntity player) { if (PolymerServerNetworking.getSupportedVersion(player.networkHandler, PACKET_ID) > 0) { // Client state for modded return this; } else { // Client state for vanilla return VanillaObjects.SOMETHING; }} This section is incomplete... I hope in code comments will guide you well...","title":"Client side features"},{"location":"polymer-core/client-side/#client-side-features","text":"While Polymer by itself is mainly server side api, it includes some client side functionality for mods to use. It allows you for example to display vanilla friendly item for normal clients and custom models if it's present on server.","title":"Client side features"},{"location":"polymer-core/client-side/#keeping-modded-itemblock-on-compatible-client","text":"To keep client side model for loading, you need to implement PolymerKeepModel interface on your modded object. To enable it's decoding, just add PolymerClientDecoded interface for it. After that, you just need to return server side items/block in corresponding player-aware getPolymerX methods. To \"sync\" presence/version of your mod you can use Polymer's handshake feature. You can do that by registering packets for which you should check Polymer Networking documentation After that you can just validate if player supports it with this check it like this SomeObject getPolymerX(ServerPlayerEntity player) { if (PolymerServerNetworking.getSupportedVersion(player.networkHandler, PACKET_ID) > 0) { // Client state for modded return this; } else { // Client state for vanilla return VanillaObjects.SOMETHING; }}","title":"Keeping modded item/block on compatible client."},{"location":"polymer-core/client-side/#this-section-is-incomplete-i-hope-in-code-comments-will-guide-you-well","text":"","title":"This section is incomplete... I hope in code comments will guide you well..."},{"location":"polymer-core/entities/","text":"Entities Note These docs will only take care about polymer-related part of creation of entities. You might want to see official Fabric Wiki for more in depth look into how to create entities. You can skip most client side specific things, as it won't take effect server side (for example rendering/models) Creation of entities Creation of entities is mostly the same as vanilla. You just need to implement PolymerEntity interface on your entity's class. It exposes few defaulted methods for manipulation of client side visuals. You also need to register your entity type as virtual, by using PolymerEntityUtils.registerType(EntityType... types) . Changing client side entity. To select visual entity type, you just need to override EntityType<?> getPolymerEntityType(ServerPlayerEntity player) This method can't return null or another EntityType that points to other virtual entity, as it won't work. Example use: Displaying entity as zombie @Override public EntityType<?> getPolymerEntityType(ServerPlayerEntity player) { return EntityType.ZOMBIE; } Modifying held items You most likely want to modify items held by entity, to indicate its type. To do it you need to override List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(List<Pair<EquipmentSlot, ItemStack>> items, ServerPlayerEntities player) . Example use: Displaying real items with helmet replacement. @Override public List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(List<Pair<EquipmentSlot, ItemStack>> items, ServerPlayerEntities player) { var list = new ArrayList<Pair<EquipmentSlot, ItemStack>>(map.size()); for (var entry : items) { if (entry.getKey() == EquipmentSlot.HEAD) { continue; } else { list.add(Pair.of(entry.getKey(), entry.getValue())); } } list.add(new Pair<>(EquipmentSlot.HEAD, new ItemStack(Items.WITHER_SKELETON_SKULL))); return list; } Modifying client-side data trackers For more control over entity, you can modify DataTracker values send to client directly. To do it, you need to override void modifyRawTrackedData(List<DataTracker.SerializedEntry<?>> data, ServerPlayerEntity player, boolean initial) method. You should also be safe around it, as sending DataTracker.Entry's, that don't exist on client-side entity representation will cause issues and errors! To get TrackedData , which is needed to create Entries, you can either use accessors, or manually construct the data. Example use: Adding villager data to change how villager looks @Override public void modifyRawTrackedData(List<DataTracker.SerializedEntry<?>> data, ServerPlayerEntity player, boolean initial) { data.add(DataTracker.SerializedEntry.of(VillagerEntityAccessor.getVillagerData(), new VillagerData(VillagerType.JUNGLE, VillagerProfession.FARMER, 3);)); }","title":"Entities"},{"location":"polymer-core/entities/#entities","text":"Note These docs will only take care about polymer-related part of creation of entities. You might want to see official Fabric Wiki for more in depth look into how to create entities. You can skip most client side specific things, as it won't take effect server side (for example rendering/models)","title":"Entities"},{"location":"polymer-core/entities/#creation-of-entities","text":"Creation of entities is mostly the same as vanilla. You just need to implement PolymerEntity interface on your entity's class. It exposes few defaulted methods for manipulation of client side visuals. You also need to register your entity type as virtual, by using PolymerEntityUtils.registerType(EntityType... types) .","title":"Creation of entities"},{"location":"polymer-core/entities/#changing-client-side-entity","text":"To select visual entity type, you just need to override EntityType<?> getPolymerEntityType(ServerPlayerEntity player) This method can't return null or another EntityType that points to other virtual entity, as it won't work. Example use: Displaying entity as zombie @Override public EntityType<?> getPolymerEntityType(ServerPlayerEntity player) { return EntityType.ZOMBIE; }","title":"Changing client side entity."},{"location":"polymer-core/entities/#modifying-held-items","text":"You most likely want to modify items held by entity, to indicate its type. To do it you need to override List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(List<Pair<EquipmentSlot, ItemStack>> items, ServerPlayerEntities player) . Example use: Displaying real items with helmet replacement. @Override public List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(List<Pair<EquipmentSlot, ItemStack>> items, ServerPlayerEntities player) { var list = new ArrayList<Pair<EquipmentSlot, ItemStack>>(map.size()); for (var entry : items) { if (entry.getKey() == EquipmentSlot.HEAD) { continue; } else { list.add(Pair.of(entry.getKey(), entry.getValue())); } } list.add(new Pair<>(EquipmentSlot.HEAD, new ItemStack(Items.WITHER_SKELETON_SKULL))); return list; }","title":"Modifying held items"},{"location":"polymer-core/entities/#modifying-client-side-data-trackers","text":"For more control over entity, you can modify DataTracker values send to client directly. To do it, you need to override void modifyRawTrackedData(List<DataTracker.SerializedEntry<?>> data, ServerPlayerEntity player, boolean initial) method. You should also be safe around it, as sending DataTracker.Entry's, that don't exist on client-side entity representation will cause issues and errors! To get TrackedData , which is needed to create Entries, you can either use accessors, or manually construct the data. Example use: Adding villager data to change how villager looks @Override public void modifyRawTrackedData(List<DataTracker.SerializedEntry<?>> data, ServerPlayerEntity player, boolean initial) { data.add(DataTracker.SerializedEntry.of(VillagerEntityAccessor.getVillagerData(), new VillagerData(VillagerType.JUNGLE, VillagerProfession.FARMER, 3);)); }","title":"Modifying client-side data trackers"},{"location":"polymer-core/getting-started/","text":"Getting Started This is the first and most important library for server side development. It allows you to create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones allowing for way better mod compatibility and way less weird edge-cases. This library also handles all mod compatibility with client only mods (when it's present), so it can be safely used in a modpack. Adding to dependencies repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-core:[TAG]\") } For [TAG] /polymer-core version I recommend you checking this maven . Latest version: Before starting There are few things you need to keep in mind while using Polymer. All your code that interacts with Polymer should: Be thread safe - code can run on main server thread, player's connection thread or client side rendering thread. Make sure to check every time you cast if it's really instance of it. Sometimes World won't be ServerWorld . Never implement Polymer interfaces on Vanilla Items/Blocks with mixins, it will end up really, really badly. Never add new BlockStates to non-polymer blocks, as it will cause desyncs (see previous point)! Please don't even try using registry replacement, it will break many other mods (and polymer itself). Polymer is split into multiple libraries with varying functionality.","title":"Getting Started"},{"location":"polymer-core/getting-started/#getting-started","text":"This is the first and most important library for server side development. It allows you to create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones allowing for way better mod compatibility and way less weird edge-cases. This library also handles all mod compatibility with client only mods (when it's present), so it can be safely used in a modpack.","title":"Getting Started"},{"location":"polymer-core/getting-started/#adding-to-dependencies","text":"repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-core:[TAG]\") } For [TAG] /polymer-core version I recommend you checking this maven . Latest version:","title":"Adding to dependencies"},{"location":"polymer-core/getting-started/#before-starting","text":"There are few things you need to keep in mind while using Polymer. All your code that interacts with Polymer should: Be thread safe - code can run on main server thread, player's connection thread or client side rendering thread. Make sure to check every time you cast if it's really instance of it. Sometimes World won't be ServerWorld . Never implement Polymer interfaces on Vanilla Items/Blocks with mixins, it will end up really, really badly. Never add new BlockStates to non-polymer blocks, as it will cause desyncs (see previous point)! Please don't even try using registry replacement, it will break many other mods (and polymer itself). Polymer is split into multiple libraries with varying functionality.","title":"Before starting"},{"location":"polymer-core/items/","text":"Items Note These docs will only take care about polymer-related part of creation of items. You might want to see official Fabric Wiki for more in depth look into how to create items. You can skip some client side specific things, as it won't take effect server side (excluding item groups, as they can be used by other mods) Creation of items Creation of items is mostly the same as vanilla. Only real difference is that your items need to implement Polymer's PolymerItem interface. It exposes few defaulted methods for manipulation of client side visuals. Default implementation For most basic uses, there are default implementation of PolymerItem : SimplePolymerItem - Same as vanilla Item , PolymerSpawnEggItem - Same as vanilla SpawnEggItem , PolymerBlockItem - Same as vanilla BlockItem , PolymerHeadBlockItem - Similar to PolymerBlockItem , but for Blocks implementing PolymerHeadBlock interface. Selecting visual item type. To select visual item type, you need to implement this method * Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) They can't return nulls. They can also point to other PolymerItem instance, but keep in mind to make validation if it's configurable by user! Example use: Changing client-side item to diamond @Override public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) { return itemStack.getCount() > 32 ? Items.DIAMOND_BLOCK : Items.DIAMOND; } Manipulation of client side ItemStack Sometimes it's useful to manipulate entire ItemStack, as it allows achieving better effects. To do so, you need to override the ItemStack getPolymerItemStack(ItemStack itemStack, TooltipContext context, @Nullable ServerPlayerEntity player) method. However, keep in mind that making nbt incorrect might create some issues (for example breaking items in creative mode)! Ideally you should modify output of PolymerItem.super.getPolymerItemStack(itemStack, context, player) , PolymerItemUtils.createItemStack(itemStack, player) or PolymerItemUtils.createMinimalItemStack(itemStack, player) , as they contain all required NBT. Example use: Adding enchanting glint to item. @Override public ItemStack getPolymerItemStack(ItemStack itemStack, TooltipContext context, ServerPlayerEntity player) { ItemStack out = PolymerItemUtils.createItemStack(itemStack, context, player); out.addEnchantment(Enchantments.LURE, 0); return out; } Support of models/CustomModelData You can change custom model data of virtual model by simple overriding int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) . You can return -1 to disable it, or any number above it to set value of it. Ideally you should return value created with polymer's resource pack utils , but nothing blocks you from using any other ones. Example usage: Changing client-side item CustomModelData to previously stored value. @Override public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) { // Instance of PolymerModelData, see info above return this.cmd.value(); } Item Groups support You can create server side Item Groups, which will be later synced with Polymer-compatible clients. They also allow you to create server side Creative categories, that are accessible via /polymer creative command. To create, it, you just need to call one of provided PolymerItemGroupUtils.builder(Identifier) static method. Then you can create it just like regular ItemGroup. Manipulation of non-polymer items Sometimes, you might want to manipulate other vanilla/modded items without implementing PolymerItem on them. You can do it by using few events from PolymerItemUtils . Forcing items to go through Polymer To force items to go through polymer's client side item creation, you need to register event handler for PolymerItemUtils.ITEM_CHECK event. You can register it by using PolymerItemUtils.ITEM_CHECK.register(ItemStack -> boolean) lambda. Example use: Making every item with string NBT tag of \"Test\" go through polymer PolymerItemUtils.ITEM_CHECK.register( (itemStack) -> { return itemStack.hasNbt() && itemStack.getNbt().contains(\"Test\", NbtElement.STRING_TYPE); } ); Modification of Client side item After getting vanilla (or for any PolymerItem by default) you can modify any client side item with PolymerItemUtils.ITEM_MODIFICATION_EVENT event. Just keep in mind doing it incorrectly can cause issues (mostly around creative mode, but also in case you modify original item). You change the client side item by either directly modifying client ItemStack or creating new one and returning it. Ideally you should also keep previous nbt, just so it can work nicely, You can register this event by using PolymerItemUtils.ITEM_MODIFICATION_EVENT.register(((ItemStack original, ItemStack client, ServerPlayerEntity player) -> ItemStack) lambda. Example use: Hiding enchantment glint for items with HideEnchantments: 1b nbt tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, client, player) -> { if (original.hasNbt() && original.getNbt().getBoolean(\"HideEnchantments\")) { client.getNbt().remove(\"Enchantments\"); } return client; } ); Replacing look/name of ItemStack with \"Test\" NBT tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, client, player) -> { if (original.hasNbt() && original.getNbt().contains(\"Test\", NbtElement.STRING_TYPE)) { ItemStack out = new ItemStack(Items.DIAMOND_SWORD, client.getCount()); out.setNbt(client.getNbt()); out.setCustomName(new LiteralText(\"TEST VALUE: \" + original.getNbt().getString(\"Test\")).formatted(Formatting.WHITE)); return out; } return client; } ); Making items mining calculated on server side You can also force item's mining speed to be calculated server side (which happens by default to every PolymerItem). Only thing you need to do is just listening to BlockHelper.SERVER_SIDE_MINING_CHECK event. Example use: PolymerBlockUtils.SERVER_SIDE_MINING_CHECK.register( (player, pos, blockState) -> { var itemStack = player.getMainHandStack(); return EnchantmentHelper.getLevel(MyEnchanments.SLOW_MINING, itemStack) > 0; } ); Enchantments The only thing to make your enchantment fully server side is implementation of PolymerSyncedObject or PolymerEnchantment interface. You also might want to manipulate some things from Polymer Block/Item events.","title":"Items"},{"location":"polymer-core/items/#items","text":"Note These docs will only take care about polymer-related part of creation of items. You might want to see official Fabric Wiki for more in depth look into how to create items. You can skip some client side specific things, as it won't take effect server side (excluding item groups, as they can be used by other mods)","title":"Items"},{"location":"polymer-core/items/#creation-of-items","text":"Creation of items is mostly the same as vanilla. Only real difference is that your items need to implement Polymer's PolymerItem interface. It exposes few defaulted methods for manipulation of client side visuals.","title":"Creation of items"},{"location":"polymer-core/items/#default-implementation","text":"For most basic uses, there are default implementation of PolymerItem : SimplePolymerItem - Same as vanilla Item , PolymerSpawnEggItem - Same as vanilla SpawnEggItem , PolymerBlockItem - Same as vanilla BlockItem , PolymerHeadBlockItem - Similar to PolymerBlockItem , but for Blocks implementing PolymerHeadBlock interface.","title":"Default implementation"},{"location":"polymer-core/items/#selecting-visual-item-type","text":"To select visual item type, you need to implement this method * Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) They can't return nulls. They can also point to other PolymerItem instance, but keep in mind to make validation if it's configurable by user! Example use: Changing client-side item to diamond @Override public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) { return itemStack.getCount() > 32 ? Items.DIAMOND_BLOCK : Items.DIAMOND; }","title":"Selecting visual item type."},{"location":"polymer-core/items/#manipulation-of-client-side-itemstack","text":"Sometimes it's useful to manipulate entire ItemStack, as it allows achieving better effects. To do so, you need to override the ItemStack getPolymerItemStack(ItemStack itemStack, TooltipContext context, @Nullable ServerPlayerEntity player) method. However, keep in mind that making nbt incorrect might create some issues (for example breaking items in creative mode)! Ideally you should modify output of PolymerItem.super.getPolymerItemStack(itemStack, context, player) , PolymerItemUtils.createItemStack(itemStack, player) or PolymerItemUtils.createMinimalItemStack(itemStack, player) , as they contain all required NBT. Example use: Adding enchanting glint to item. @Override public ItemStack getPolymerItemStack(ItemStack itemStack, TooltipContext context, ServerPlayerEntity player) { ItemStack out = PolymerItemUtils.createItemStack(itemStack, context, player); out.addEnchantment(Enchantments.LURE, 0); return out; }","title":"Manipulation of client side ItemStack"},{"location":"polymer-core/items/#support-of-modelscustommodeldata","text":"You can change custom model data of virtual model by simple overriding int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) . You can return -1 to disable it, or any number above it to set value of it. Ideally you should return value created with polymer's resource pack utils , but nothing blocks you from using any other ones. Example usage: Changing client-side item CustomModelData to previously stored value. @Override public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) { // Instance of PolymerModelData, see info above return this.cmd.value(); }","title":"Support of models/CustomModelData"},{"location":"polymer-core/items/#item-groups-support","text":"You can create server side Item Groups, which will be later synced with Polymer-compatible clients. They also allow you to create server side Creative categories, that are accessible via /polymer creative command. To create, it, you just need to call one of provided PolymerItemGroupUtils.builder(Identifier) static method. Then you can create it just like regular ItemGroup.","title":"Item Groups support"},{"location":"polymer-core/items/#manipulation-of-non-polymer-items","text":"Sometimes, you might want to manipulate other vanilla/modded items without implementing PolymerItem on them. You can do it by using few events from PolymerItemUtils .","title":"Manipulation of non-polymer items"},{"location":"polymer-core/items/#forcing-items-to-go-through-polymer","text":"To force items to go through polymer's client side item creation, you need to register event handler for PolymerItemUtils.ITEM_CHECK event. You can register it by using PolymerItemUtils.ITEM_CHECK.register(ItemStack -> boolean) lambda. Example use: Making every item with string NBT tag of \"Test\" go through polymer PolymerItemUtils.ITEM_CHECK.register( (itemStack) -> { return itemStack.hasNbt() && itemStack.getNbt().contains(\"Test\", NbtElement.STRING_TYPE); } );","title":"Forcing items to go through Polymer"},{"location":"polymer-core/items/#modification-of-client-side-item","text":"After getting vanilla (or for any PolymerItem by default) you can modify any client side item with PolymerItemUtils.ITEM_MODIFICATION_EVENT event. Just keep in mind doing it incorrectly can cause issues (mostly around creative mode, but also in case you modify original item). You change the client side item by either directly modifying client ItemStack or creating new one and returning it. Ideally you should also keep previous nbt, just so it can work nicely, You can register this event by using PolymerItemUtils.ITEM_MODIFICATION_EVENT.register(((ItemStack original, ItemStack client, ServerPlayerEntity player) -> ItemStack) lambda. Example use: Hiding enchantment glint for items with HideEnchantments: 1b nbt tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, client, player) -> { if (original.hasNbt() && original.getNbt().getBoolean(\"HideEnchantments\")) { client.getNbt().remove(\"Enchantments\"); } return client; } ); Replacing look/name of ItemStack with \"Test\" NBT tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, client, player) -> { if (original.hasNbt() && original.getNbt().contains(\"Test\", NbtElement.STRING_TYPE)) { ItemStack out = new ItemStack(Items.DIAMOND_SWORD, client.getCount()); out.setNbt(client.getNbt()); out.setCustomName(new LiteralText(\"TEST VALUE: \" + original.getNbt().getString(\"Test\")).formatted(Formatting.WHITE)); return out; } return client; } );","title":"Modification of Client side item"},{"location":"polymer-core/items/#making-items-mining-calculated-on-server-side","text":"You can also force item's mining speed to be calculated server side (which happens by default to every PolymerItem). Only thing you need to do is just listening to BlockHelper.SERVER_SIDE_MINING_CHECK event. Example use: PolymerBlockUtils.SERVER_SIDE_MINING_CHECK.register( (player, pos, blockState) -> { var itemStack = player.getMainHandStack(); return EnchantmentHelper.getLevel(MyEnchanments.SLOW_MINING, itemStack) > 0; } );","title":"Making items mining calculated on server side"},{"location":"polymer-core/items/#enchantments","text":"The only thing to make your enchantment fully server side is implementation of PolymerSyncedObject or PolymerEnchantment interface. You also might want to manipulate some things from Polymer Block/Item events.","title":"Enchantments"},{"location":"polymer-core/other/","text":"Other custom features SoundEvents Polymer has support for creating custom sound events, that can fallback to vanilla sounds for players without resource packs and resource pack ones if they are present. To use it, you just need to create new instance of PolymerSoundEvent . You can use it similarly to vanilla ones. Custom statistics To register custom, server side statistic you just need to call PolymerStat.registerStat(Identifier, StatFormatter) . Then you can use it just like vanilla ones. StatusEffects To create custom, server side status effects, you just need to implement PolymerStatusEffect on your custom StatusEffect class. You can also override StatusEffect getPolymerStatusEffect() to display it as vanilla one (otherwise they are hidden).","title":"Other custom features"},{"location":"polymer-core/other/#other-custom-features","text":"","title":"Other custom features"},{"location":"polymer-core/other/#soundevents","text":"Polymer has support for creating custom sound events, that can fallback to vanilla sounds for players without resource packs and resource pack ones if they are present. To use it, you just need to create new instance of PolymerSoundEvent . You can use it similarly to vanilla ones.","title":"SoundEvents"},{"location":"polymer-core/other/#custom-statistics","text":"To register custom, server side statistic you just need to call PolymerStat.registerStat(Identifier, StatFormatter) . Then you can use it just like vanilla ones.","title":"Custom statistics"},{"location":"polymer-core/other/#statuseffects","text":"To create custom, server side status effects, you just need to implement PolymerStatusEffect on your custom StatusEffect class. You can also override StatusEffect getPolymerStatusEffect() to display it as vanilla one (otherwise they are hidden).","title":"StatusEffects"},{"location":"polymer-networking/basics/","text":"Basics Registering assets This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization. Adding mod assets to resource pack First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean PolymerResourcePackUtils.addModAssets(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer. Additionally, you can add assets manually by calling PolymerRPBuilder.addData(String path, byte[] data) . You can get instance of it by listening to PolymerResourcePackUtils.RESOURCE_PACK_CREATION_EVENT . Just keep in minds that new one will be created every time resource pack is generated. Requesting model for item After that you can register your models by calling PolymerModelData PolymerResourcePackUtils.requestModel(Item vanillaItem, Identifier modelPath) . It returns PolymerModelData with contains all information you need for applying custom model data to your items. You need to keep in mind, that modelPath needs to contain main directory (in similar way to vanilla models). While model is created, all it's overrides are copied and applied, so you don't need to request them manually (useful for bows). You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: PolymerModelData modelData = PolymerResourcePackUtils.requestModel(Items.IRON_SWORD, new Identifier(\"mymod\", \"item/silver_sword\")); Requesting armor textures Polymer supports custom armor textures thanks to usage of Ancientkingg's fancyPants resource pack . To request it you need to use PolymerResourcePackUtils.requestArmor(Identifier) . It will automatically create variant of every armor peace, however you aren't required to use/define them all. To apply it to your armor, you need to set your client side item to leather armor peace. Then you need to override PolymerItem.getPolymerArmorColor() method and return used color. PolymerArmorModel armorModel = PolymerResourcePackUtils.requestArmor(new Identifier(\"mymod\", \"silver\")); Checking players Checking if player has resource pack is quite simple. You just need to call boolean PolymerResourcePackUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (PolymerResourcePackUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); } Making pack required To make font required, you just need to call PolymerResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible. Building resource pack To create resource pack you only need to execute /polymer generate-pack command. Resource pack will be located in your server folder as polymer-resourcepack.zip .","title":"Basics"},{"location":"polymer-networking/basics/#basics","text":"","title":"Basics"},{"location":"polymer-networking/basics/#registering-assets","text":"This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization.","title":"Registering assets"},{"location":"polymer-networking/basics/#adding-mod-assets-to-resource-pack","text":"First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean PolymerResourcePackUtils.addModAssets(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer. Additionally, you can add assets manually by calling PolymerRPBuilder.addData(String path, byte[] data) . You can get instance of it by listening to PolymerResourcePackUtils.RESOURCE_PACK_CREATION_EVENT . Just keep in minds that new one will be created every time resource pack is generated.","title":"Adding mod assets to resource pack"},{"location":"polymer-networking/basics/#requesting-model-for-item","text":"After that you can register your models by calling PolymerModelData PolymerResourcePackUtils.requestModel(Item vanillaItem, Identifier modelPath) . It returns PolymerModelData with contains all information you need for applying custom model data to your items. You need to keep in mind, that modelPath needs to contain main directory (in similar way to vanilla models). While model is created, all it's overrides are copied and applied, so you don't need to request them manually (useful for bows). You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: PolymerModelData modelData = PolymerResourcePackUtils.requestModel(Items.IRON_SWORD, new Identifier(\"mymod\", \"item/silver_sword\"));","title":"Requesting model for item"},{"location":"polymer-networking/basics/#requesting-armor-textures","text":"Polymer supports custom armor textures thanks to usage of Ancientkingg's fancyPants resource pack . To request it you need to use PolymerResourcePackUtils.requestArmor(Identifier) . It will automatically create variant of every armor peace, however you aren't required to use/define them all. To apply it to your armor, you need to set your client side item to leather armor peace. Then you need to override PolymerItem.getPolymerArmorColor() method and return used color. PolymerArmorModel armorModel = PolymerResourcePackUtils.requestArmor(new Identifier(\"mymod\", \"silver\"));","title":"Requesting armor textures"},{"location":"polymer-networking/basics/#checking-players","text":"Checking if player has resource pack is quite simple. You just need to call boolean PolymerResourcePackUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (PolymerResourcePackUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); }","title":"Checking players"},{"location":"polymer-networking/basics/#making-pack-required","text":"To make font required, you just need to call PolymerResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible.","title":"Making pack required"},{"location":"polymer-networking/basics/#building-resource-pack","text":"To create resource pack you only need to execute /polymer generate-pack command. Resource pack will be located in your server folder as polymer-resourcepack.zip .","title":"Building resource pack"},{"location":"polymer-networking/getting-started/","text":"Getting Started This is module of Polymer containing all client <-> server networking apis, including some more uncommon ones. Adding to dependencies repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-networking:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version:","title":"Getting Started"},{"location":"polymer-networking/getting-started/#getting-started","text":"This is module of Polymer containing all client <-> server networking apis, including some more uncommon ones.","title":"Getting Started"},{"location":"polymer-networking/getting-started/#adding-to-dependencies","text":"repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-networking:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version:","title":"Adding to dependencies"},{"location":"polymer-resource-pack/basics/","text":"Basics Registering assets This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization. Adding mod assets to resource pack First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean PolymerResourcePackUtils.addModAssets(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer. Additionally, you can add assets manually by calling PolymerRPBuilder.addData(String path, byte[] data) . You can get instance of it by listening to PolymerResourcePackUtils.RESOURCE_PACK_CREATION_EVENT . Just keep in minds that new one will be created every time resource pack is generated. Requesting model for item After that you can register your models by calling PolymerModelData PolymerResourcePackUtils.requestModel(Item vanillaItem, Identifier modelPath) . It returns PolymerModelData with contains all information you need for applying custom model data to your items. You need to keep in mind, that modelPath needs to contain main directory (in similar way to vanilla models). While model is created, all it's overrides are copied and applied, so you don't need to request them manually (useful for bows). You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: PolymerModelData modelData = PolymerResourcePackUtils.requestModel(Items.IRON_SWORD, new Identifier(\"mymod\", \"item/silver_sword\")); Requesting armor textures Polymer supports custom armor textures thanks to usage of Ancientkingg's fancyPants resource pack . To request it you need to use PolymerResourcePackUtils.requestArmor(Identifier) . It will automatically create variant of every armor peace, however you aren't required to use/define them all. To apply it to your armor, you need to set your client side item to leather armor peace. Then you need to override PolymerItem.getPolymerArmorColor() method and return used color. PolymerArmorModel armorModel = PolymerResourcePackUtils.requestArmor(new Identifier(\"mymod\", \"silver\")); Checking players Checking if player has resource pack is quite simple. You just need to call boolean PolymerResourcePackUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (PolymerResourcePackUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); } Making pack required To make font required, you just need to call PolymerResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible. Building resource pack To create resource pack you only need to execute /polymer generate-pack command. Resource pack will be located in your server folder as polymer-resourcepack.zip .","title":"Basics"},{"location":"polymer-resource-pack/basics/#basics","text":"","title":"Basics"},{"location":"polymer-resource-pack/basics/#registering-assets","text":"This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization.","title":"Registering assets"},{"location":"polymer-resource-pack/basics/#adding-mod-assets-to-resource-pack","text":"First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean PolymerResourcePackUtils.addModAssets(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer. Additionally, you can add assets manually by calling PolymerRPBuilder.addData(String path, byte[] data) . You can get instance of it by listening to PolymerResourcePackUtils.RESOURCE_PACK_CREATION_EVENT . Just keep in minds that new one will be created every time resource pack is generated.","title":"Adding mod assets to resource pack"},{"location":"polymer-resource-pack/basics/#requesting-model-for-item","text":"After that you can register your models by calling PolymerModelData PolymerResourcePackUtils.requestModel(Item vanillaItem, Identifier modelPath) . It returns PolymerModelData with contains all information you need for applying custom model data to your items. You need to keep in mind, that modelPath needs to contain main directory (in similar way to vanilla models). While model is created, all it's overrides are copied and applied, so you don't need to request them manually (useful for bows). You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: PolymerModelData modelData = PolymerResourcePackUtils.requestModel(Items.IRON_SWORD, new Identifier(\"mymod\", \"item/silver_sword\"));","title":"Requesting model for item"},{"location":"polymer-resource-pack/basics/#requesting-armor-textures","text":"Polymer supports custom armor textures thanks to usage of Ancientkingg's fancyPants resource pack . To request it you need to use PolymerResourcePackUtils.requestArmor(Identifier) . It will automatically create variant of every armor peace, however you aren't required to use/define them all. To apply it to your armor, you need to set your client side item to leather armor peace. Then you need to override PolymerItem.getPolymerArmorColor() method and return used color. PolymerArmorModel armorModel = PolymerResourcePackUtils.requestArmor(new Identifier(\"mymod\", \"silver\"));","title":"Requesting armor textures"},{"location":"polymer-resource-pack/basics/#checking-players","text":"Checking if player has resource pack is quite simple. You just need to call boolean PolymerResourcePackUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (PolymerResourcePackUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); }","title":"Checking players"},{"location":"polymer-resource-pack/basics/#making-pack-required","text":"To make font required, you just need to call PolymerResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible.","title":"Making pack required"},{"location":"polymer-resource-pack/basics/#building-resource-pack","text":"To create resource pack you only need to execute /polymer generate-pack command. Resource pack will be located in your server folder as polymer-resourcepack.zip .","title":"Building resource pack"},{"location":"polymer-resource-pack/getting-started/","text":"Getting Started This is additional module/extension of Polymer, adding support for textured blocks. It requires server resource pack to be active work correctly. Adding to dependencies repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-resource-pack:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version:","title":"Getting Started"},{"location":"polymer-resource-pack/getting-started/#getting-started","text":"This is additional module/extension of Polymer, adding support for textured blocks. It requires server resource pack to be active work correctly.","title":"Getting Started"},{"location":"polymer-resource-pack/getting-started/#adding-to-dependencies","text":"repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-resource-pack:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version:","title":"Adding to dependencies"}]}